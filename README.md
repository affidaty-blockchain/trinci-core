TRINCI Blockchain Core
======================

A lightweight and flexible framework to build your tailored blockchain applications.

## Requirements

The required dependencies to build correctly the project are the following:

- clang
- libclang-dev (ver. 11 suggested)

follow the installations for the most common Unix/Linux systems 

### Ubuntu/Debian installation

update the package list:

```
sudo apt-get update
```

install the dependencies:

```
sudo apt-get install clang libclang-dev
```

### Fedora/RHEL installation

update the package list:

```
sudo dnf check-update
```

install the dependencies:
```
sudo dnf install clang rust-clang-sys+clang_11_0-devel
```

### TPM2 module requirements

in case of the optional feature for the TPM2 module is enabled, the following dependencies are needed:

- libtss2-dev

#### Ubintu/Debian installation


install the dependencies:

follow [this guide](https://github.com/tpm2-software/tpm2-tss/blob/master/INSTALL.md)


### Fedora/RHEL installation

install the dependencies:
```
sudo dnf install tpm2-tss
```

## Build

to build the cargo package:

```
cd ./trinci-core
cargo build
```

References
----------

[Link to lightpaper](https://github.com/affidaty-blockchain/whitepaper) 

## Schemas

### Bulk Transaction

A bulk transaction is a group of atomic transactions. In other words, if one of the transactions fails, the whole group fails.

The logical representation of a **bulk transaction** is composed of a **root transaction** and a group of **node transactions**. The **node** is an *unsigned transaction* generated by the creator of the bulk transaction. Subsequent transactions are a vector of *signed transactions* defined as **node transactions**, which in addition to containing the traditional information included in a transaction point to the root transaction. 

```rust
pub struct BulkTransaction {
    /// Transaction payload.
    pub data: TransactionData,
    /// Data field signature verifiable using the `caller` within the `data`.
    #[serde(with = "serde_bytes")]
    pub signature: Vec<u8>,
}
```

A bulk transaction is composed by a `TransactionData` structure and a `signature`. The signature is done by the owner of the node transaction once the bulk transaction is completed.

As `TransactionData`, is expected a `BulkV1` variant:

```rust
pub enum TransactionData {
    #[serde(rename = "v1")]
    V1(TransactionDataV1),
    #[serde(rename = "bnv1")]
    BulkNodeV1(TransactionDataBulkNodeV1),
    #[serde(rename = "brv1")]
    BulkRootV1(TransactionDataV1),
    #[serde(rename = "bv1")]
    BulkV1(TransactionDataBulkV1),
}
```

The `TransactionDataBulkV1` actually represents the logical structure previously presented:

```rust
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
pub struct TransactionDataBulkV1 {
    pub txs: BulkTransactions,
}

pub struct BulkTransactions {
    pub root: Box<UnsignedTransaction>,
    pub nodes: Option<Vec<SignedTransaction>>,
}
```

Lastly the Bulk Transactions have a method worth of mention:

`check_integrity() -> Result<()>`, this method checks if the transaction respects the presented structure and that it does not contain a bulk in node transactions.
